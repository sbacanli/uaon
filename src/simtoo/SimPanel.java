package simtoo;
import routing.*;


import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import javax.swing.*;

import java.util.*;
import javax.swing.Timer;




public class SimPanel extends JPanel implements MouseListener{

	Timer timer;
	
	ArrayList<Node> nodes;
	ArrayList<RoutingNode>  routingNodes;
	Uav uav;
	RoutingNode uavRoutingNode;
	

	private final int UPDATE_RATE = 10;
	int time;
	
	
	Random r;
	
	Datas mydata;
	int numrecord=1000;
	double height,width;
	
	double COMMDIST;
	int numberOfRoutesCompleted;
	int numberOfMessagesToBeCreatedByAll;
	int numberOfMessagesToBeCreatedByNodes;
	int numberOfMessagesToBeCreatedByUav;
	int messageLifeInSeconds;
	
	int poissonVar;
	int messageGeneratingNodeId;
	int numberofCreatedMessages;
	int numberOfNodes;
	int routeLimit;
	
	
	public SimPanel(Simulator simulator,Datas datagiven){
		
		super();
		r=new Random();
		mydata=datagiven;
		height= mydata.getHeight();
		width = mydata.getWidth();

		//Extracting Simulator Parameters
		nodes=simulator.getNodes();
		routingNodes=simulator.getRoutingNodes();
		uav=simulator.getUav();
		uavRoutingNode=simulator.getUavRoutingNode();
		COMMDIST=simulator.getCommDist(); 
		messageLifeInSeconds=simulator.getMessageLifeInSeconds();
		

	
		time=0;
		numberOfRoutesCompleted=0;
		numberOfNodes=nodes.size();

		routeLimit=10;	
		
		setPreferredSize(new Dimension((int)width,(int)height));
		setBackground(Color.LIGHT_GRAY);
		
		
		addMouseListener(this);

		
		/*
		ArrayList<Position> arr=nodes.get(2).getPositions();
		Lib.p("uzunluk "+arr.size());
		for(int i=1;i<arr.size();i++){
			double lat1=arr.get(i).getRealX();
			double lon1=arr.get(i).getRealY();
			double lat2=arr.get(i-1).getRealY();
			double lon2=arr.get(i-1).getRealY();
			Lib.p(Lib.realdistance(lat1, lon1, lat2, lon2)+" is the distance");
		}
		//*/
		
		numberOfMessagesToBeCreatedByAll=50;
		numberOfMessagesToBeCreatedByNodes=(int)(numberOfMessagesToBeCreatedByAll*0.6);
		numberOfMessagesToBeCreatedByUav=(int)(numberOfMessagesToBeCreatedByAll*0.4);
		
		numberofCreatedMessages=0;
		//poissonVar=LibRouting.getPoisson(3600);
		poissonVar =2;
		messageGeneratingNodeId=LibRouting.getUniform(numberOfNodes);
			
		///////////////////////////////////////////////////////////
		//addAllMessagesToUav();
		//////////////////////////////////////////////////////////

		
		TimerListener tm=new TimerListener(this,routeLimit);
		Timer timer = new Timer(1000/UPDATE_RATE, tm);
        timer.start();
 
	}
		
	private void drawImage(String img1,Graphics2D g2d,double x,double y){
		Image img11 = Toolkit.getDefaultToolkit().getImage(img1);
		
        /* draw ball image to the memory image with transformed x/y double values */
        AffineTransform t = new AffineTransform();
        t.translate(x, y); // x/y set here, ball.x/y = double, ie: 10.33
        t.scale(0.1, 0.1); // scale = 1 
        g2d.drawImage(img11,t, null);
      
	}
	
	
	private void drawFigures(Graphics2D g2){
		int nodesize=15;
		
		//Drawing the nodes
        for(int i=0;i<nodes.size();i++){
        	double x=0;
        	double y=0;
        	x=nodes.get(i).getScreenPosition().getX();
        	y=nodes.get(i).getScreenPosition().getY();		
	        	
        	
        	Shape node = new Ellipse2D.Double(x, y, nodesize, nodesize); 
            int rval=(9*i+55)%256;
        	int gval=(6*i+35)%256;
        	int bval=(7*i+15)%256;
        	g2.setPaint(new Color(rval, gval, bval)); // a dull blue-green
            g2.fill(node);
            g2.draw (node);
        }
        
        double xuav=uav.getScreenPosition().getX();
        double yuav=uav.getScreenPosition().getY();
        
        if(uav.isRouteFinished()){
        	uav.reRoute();
        	numberOfRoutesCompleted++;
        }
        drawImage("drone.png", g2,xuav, yuav);

	}
	
	public int getNumberOfRoutesCompleted(){
		return numberOfRoutesCompleted;
	}
	
	public void simulationEnded(){
		Lib.p("Number of created messages "+numberofCreatedMessages);
		Computer.run(nodes, routingNodes, uav, uavRoutingNode,numberofCreatedMessages);
		Reporter.closeFile();
		System.exit(-1);
	}
	
	public void addAllMessagesToUav(){
		
		for(int i=0;i<numberOfMessagesToBeCreatedByUav;i++){	
			String expiration=-1+"";
			int prevPacketId=-1;
			int hopcount=0;
			int senderId=0;
			int receiverId=LibRouting.getUniform(numberOfNodes);
			int tts=-1;//tts is disabled
			int creationTime=time+1;
			//as the message is generated by the node the sender will be -1
			//receiver will be the node itself.
			int messageId=100+i;
			Message message1=new Message(prevPacketId, senderId,receiverId, 
					"This is The Message "+messageId,
					(i+1), creationTime+"",tts,expiration,hopcount);
			
			uavRoutingNode.addtoBuffer(message1, time+"");
			numberofCreatedMessages++;
		}
	}
	
	//this is called after drawing everything
	//anything here will be done once for every time.
	public void increaseTime(){
		Lib.p("time passing " +time);
		if(time==poissonVar){
			//48 hours Expiration time
			int messageNumber=numberofCreatedMessages+1;
			String expiration=(poissonVar+messageLifeInSeconds)+"";
			int prevPacketId=-1;
			int hopcount=0;
			int senderId=-1;
			int tts=-1;//tts is disabled
			//as the message is generated by the node the sender will be -1
			//receiver will be the node itself.
			int timegiven=1;
			if(time != 0){
				timegiven=time;
			}
			Message message1=new Message(prevPacketId, senderId,messageGeneratingNodeId, 
					"This is The Message "+messageNumber,
					messageNumber, timegiven+"",tts,expiration,hopcount);
			
			routingNodes.get(messageGeneratingNodeId-1).addtoBuffer(message1, time+"");
			
			//new message generation time is being created
			messageGeneratingNodeId=LibRouting.getUniform(numberOfNodes);
			poissonVar=poissonVar+5;
			//poissonVar=poissonVar+LibRouting.getPoisson(3600);
			numberofCreatedMessages++;
			Lib.p("HEre it is");
		}
		time++;
	}
	
	
	
	public void checkNodesDistances(){
		double xuav=uav.getRealPosition().getX();
        double yuav=uav.getRealPosition().getY();
        Position encounterUAV=mydata.getPositionWithReal(xuav, yuav);
		
        
		   for(int i=0;i<nodes.size();i++){
			    RoutingNode r1=routingNodes.get(i);
			    Node n1=nodes.get(i);
			    
	        	double x=n1.getRealPosition().getX();
	        	double y=n1.getRealPosition().getY();
	        	Position encounterR1=mydata.getPositionWithReal(x, y);
	        	//this is the position of R1 when encountered with some node
	        	
	        	for(int j=0;j<i;j++){
	        		
					RoutingNode r2=routingNodes.get(j);
					Node n2=nodes.get(j);
					
	        		if(i != j){
						double otherx=n2.getRealPosition().getX();
						double othery=n2.getRealPosition().getY();
						Position encounterR2=mydata.getPositionWithReal(otherx, othery);
						//this is the position of R2 when encountered with some node
						
						
						if(Lib.distance(x, y, otherx, othery) <= COMMDIST){
							
							//if they are not in contact let us make them in contact
							if(!r2.isInContactWith(routingNodes.get(i).getId())){
								r2.addContact(r1.getId(),encounterR2, time); 
								r1.addContact(r2.getId(),encounterR1, time);								
								r2.addEncounter(r1.getId(),encounterR2, time); 
								r1.addEncounter(r2.getId(),encounterR1, time);
								
								
								//first touch happened
								Simulator.nodeRoute(r1,r2,time+"");
							}//else it means they are still in contact from last time
							//this  is a continueing contact
							
							
							
							//Lib.p("nodes encountered");
							
						}else{
							//if the distance is far and they were in contact before
							//it means the contact ended.
							if(r2.isInContactWith(r1.getId())){
								r2.removeContact(r1.getId());
								r1.removeContact(r2.getId());
								Encounter e1=r1.finishEncounter(r2.getId(), time);
								Encounter e2=r2.finishEncounter(r1.getId(), time);
								
								if(e1==null || e2==null)
									Lib.p("Encounters are null in SimPanel");
								
								Reporter.writeToFile("encounters.txt", e1.toString());
							}
							//if they are far and not in contact, no need to do anything.
						
						}
						
		        	}
	        	}//end of node comparison with each other
	        	
	        	if(Lib.distance(xuav, yuav, x, y) <= COMMDIST){
	        		
	        		
	        		if(!uavRoutingNode.isInContactWith(routingNodes.get(i).getId())){
	        		
	        			uav.encounterWithNode(time,encounterUAV,nodes.get(i).getId());
	      			
	      				r1.addContact(uavRoutingNode.getId(),encounterR1, time);
	      				r1.addEncounter(uavRoutingNode.getId(),encounterR1, time);
	      			
	      				uavRoutingNode.addContact(r1.getId(),encounterUAV, time);
	      				uavRoutingNode.addEncounter(r1.getId(),encounterUAV, time);
	      			
	      				Simulator.uavRoute(uavRoutingNode,r1,time+"");
	      				//Lib.p("Uav encountered");
	        		}
	        		
	      		}else{
	      			if(r1.isInContactWith(uavRoutingNode.getId())){
	      				r1.removeContact(uavRoutingNode.getId());
	      				r1.finishEncounter(uavRoutingNode.getId(), time);
	      				uavRoutingNode.finishEncounter(r1.getId(), time);
	      				uavRoutingNode.removeContact(r1.getId());
	      				//continueing contact between node and UAV
	      			}
	      			//distance is far and there was no contact
	      			//nothing to do here
	      		}
	        }
	}
	
	private void doDrawing(Graphics g) {
        Graphics2D g2 = (Graphics2D) g;
        drawFigures(g2);

        checkNodesDistances();
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        doDrawing(g);
        increaseTime();
    }
    
    
    public void mousePressed(MouseEvent e) {
      
    }

    public void mouseReleased(MouseEvent e) {
       Lib.p(e.getX()+" coordinates   "+e.getY());
       System.exit(-1);
    }

    public void mouseEntered(MouseEvent e) {
    }

    public void mouseExited(MouseEvent e) {
    }

    public void mouseClicked(MouseEvent e) {
    	
    }

    
    public class TimerListener implements ActionListener{
    	private SimPanel parent;
    	int routeLimit;
    	
    	public TimerListener(SimPanel parent,int routeLimitgiven){
    		this.parent=parent;
    		routeLimit=routeLimitgiven;
    	}
    	
        public void actionPerformed(ActionEvent e) {
        	if ( parent.getNumberOfRoutesCompleted() > routeLimit) {
                ((Timer)e.getSource()).stop();
                Lib.p("Simulation stopped as number of rotations reached to "+routeLimit);
                parent.simulationEnded();
            }
          
            parent.repaint();
        }        
    }//end of inner class TimerListener
    
}
